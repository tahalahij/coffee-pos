<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/src/analytics/analytics.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/analytics/analytics.service.ts" />
              <option name="originalContent" value="import { Injectable } from '@nestjs/common';&#10;import { PrismaService } from '../prisma/prisma.service';&#10;&#10;@Injectable()&#10;export class AnalyticsService {&#10;  constructor(private prisma: PrismaService) {}&#10;&#10;  async getDashboardOverview() {&#10;    const today = new Date();&#10;    const startOfDay = new Date(today.setHours(0, 0, 0, 0));&#10;    const endOfDay = new Date(today.setHours(23, 59, 59, 999));&#10;&#10;    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);&#10;    const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59, 999);&#10;&#10;    const [todaySales, monthSales, totalProducts, lowStockProducts, recentSales] = await Promise.all([&#10;      // Today's sales&#10;      this.prisma.sale.aggregate({&#10;        where: {&#10;          createdAt: { gte: startOfDay, lte: endOfDay },&#10;          status: 'COMPLETED',&#10;        },&#10;        _sum: { totalAmount: true },&#10;        _count: true,&#10;      }),&#10;&#10;      // This month's sales&#10;      this.prisma.sale.aggregate({&#10;        where: {&#10;          createdAt: { gte: startOfMonth, lte: endOfMonth },&#10;          status: 'COMPLETED',&#10;        },&#10;        _sum: { totalAmount: true },&#10;        _count: true,&#10;      }),&#10;&#10;      // Total products&#10;      this.prisma.product.count({&#10;        where: { isAvailable: true },&#10;      }),&#10;&#10;      // Low stock products&#10;      this.prisma.product.count({&#10;        where: {&#10;          AND: [&#10;            { lowStockAlert: { not: null } },&#10;            { stock: { lte: { lowStockAlert: true } } },&#10;          ],&#10;        },&#10;      }),&#10;&#10;      // Recent sales&#10;      this.prisma.sale.findMany({&#10;        take: 10,&#10;        orderBy: { createdAt: 'desc' },&#10;        include: {&#10;          items: {&#10;            include: {&#10;              product: {&#10;                select: { name: true },&#10;              },&#10;            },&#10;          },&#10;        },&#10;      }),&#10;    ]);&#10;&#10;    return {&#10;      todaySales: Number(todaySales._sum.totalAmount || 0),&#10;      todayOrders: todaySales._count,&#10;      monthSales: Number(monthSales._sum.totalAmount || 0),&#10;      monthOrders: monthSales._count,&#10;      totalProducts,&#10;      lowStockProducts,&#10;      recentSales,&#10;    };&#10;  }&#10;&#10;  async getSalesAnalytics(days: number = 30) {&#10;    const endDate = new Date();&#10;    const startDate = new Date();&#10;    startDate.setDate(endDate.getDate() - days);&#10;&#10;    const sales = await this.prisma.sale.findMany({&#10;      where: {&#10;        createdAt: { gte: startDate, lte: endDate },&#10;        status: 'COMPLETED',&#10;      },&#10;      include: {&#10;        items: {&#10;          include: {&#10;            product: {&#10;              include: {&#10;                category: true,&#10;              },&#10;            },&#10;          },&#10;        },&#10;      },&#10;    });&#10;&#10;    const dailySales = this.groupSalesByDate(sales);&#10;    const topProducts = this.getTopSellingProducts(sales);&#10;    const categoryBreakdown = this.getCategoryBreakdown(sales);&#10;    const paymentMethodBreakdown = this.getPaymentMethodBreakdown(sales);&#10;&#10;    return {&#10;      dailySales,&#10;      topProducts,&#10;      categoryBreakdown,&#10;      paymentMethodBreakdown,&#10;      totalRevenue: sales.reduce((sum, sale) =&gt; sum + Number(sale.totalAmount), 0),&#10;      totalOrders: sales.length,&#10;      averageOrderValue: sales.length &gt; 0 ? sales.reduce((sum, sale) =&gt; sum + Number(sale.totalAmount), 0) / sales.length : 0,&#10;    };&#10;  }&#10;&#10;  async getProductPerformance() {&#10;    const products = await this.prisma.product.findMany({&#10;      include: {&#10;        category: true,&#10;        saleItems: {&#10;          include: {&#10;            sale: {&#10;              where: { status: 'COMPLETED' },&#10;            },&#10;          },&#10;        },&#10;      },&#10;    });&#10;&#10;    return products.map(product =&gt; {&#10;      const totalSold = product.saleItems.reduce((sum, item) =&gt; sum + item.quantity, 0);&#10;      const totalRevenue = product.saleItems.reduce((sum, item) =&gt; sum + Number(item.totalAmount), 0);&#10;&#10;      return {&#10;        id: product.id,&#10;        name: product.name,&#10;        category: product.category.name,&#10;        price: Number(product.price),&#10;        stock: product.stock,&#10;        totalSold,&#10;        totalRevenue,&#10;        profitMargin: product.cost ? ((Number(product.price) - Number(product.cost)) / Number(product.price)) * 100 : null,&#10;      };&#10;    }).sort((a, b) =&gt; b.totalRevenue - a.totalRevenue);&#10;  }&#10;&#10;  async getInventoryReport() {&#10;    const products = await this.prisma.product.findMany({&#10;      include: {&#10;        category: true,&#10;      },&#10;    });&#10;&#10;    const totalInventoryValue = products.reduce((sum, product) =&gt; {&#10;      const cost = Number(product.cost || 0);&#10;      return sum + (cost * product.stock);&#10;    }, 0);&#10;&#10;    const lowStockProducts = products.filter(product =&gt;&#10;      product.lowStockAlert &amp;&amp; product.stock &lt;= product.lowStockAlert&#10;    );&#10;&#10;    const outOfStockProducts = products.filter(product =&gt; product.stock === 0);&#10;&#10;    return {&#10;      totalProducts: products.length,&#10;      totalInventoryValue,&#10;      lowStockProducts: lowStockProducts.length,&#10;      outOfStockProducts: outOfStockProducts.length,&#10;      products: products.map(product =&gt; ({&#10;        id: product.id,&#10;        name: product.name,&#10;        category: product.category.name,&#10;        stock: product.stock,&#10;        cost: Number(product.cost || 0),&#10;        inventoryValue: (Number(product.cost || 0)) * product.stock,&#10;        lowStockAlert: product.lowStockAlert,&#10;        isLowStock: product.lowStockAlert ? product.stock &lt;= product.lowStockAlert : false,&#10;      })),&#10;    };&#10;  }&#10;&#10;  private groupSalesByDate(sales: any[]) {&#10;    const dailySales = new Map();&#10;&#10;    sales.forEach(sale =&gt; {&#10;      const date = new Date(sale.createdAt).toISOString().split('T')[0];&#10;      const existing = dailySales.get(date) || { date, sales: 0, orders: 0 };&#10;&#10;      existing.sales += Number(sale.totalAmount);&#10;      existing.orders += 1;&#10;      dailySales.set(date, existing);&#10;    });&#10;&#10;    return Array.from(dailySales.values()).sort((a, b) =&gt; a.date.localeCompare(b.date));&#10;  }&#10;&#10;  private getTopSellingProducts(sales: any[]) {&#10;    const productStats = new Map();&#10;&#10;    sales.forEach(sale =&gt; {&#10;      sale.items.forEach(item =&gt; {&#10;        const productId = item.product.id;&#10;        const existing = productStats.get(productId) || {&#10;          product: item.product,&#10;          quantity: 0,&#10;          revenue: 0,&#10;        };&#10;&#10;        existing.quantity += item.quantity;&#10;        existing.revenue += Number(item.totalAmount);&#10;        productStats.set(productId, existing);&#10;      });&#10;    });&#10;&#10;    return Array.from(productStats.values())&#10;      .sort((a, b) =&gt; b.revenue - a.revenue)&#10;      .slice(0, 10);&#10;  }&#10;&#10;  private getCategoryBreakdown(sales: any[]) {&#10;    const categoryStats = new Map();&#10;&#10;    sales.forEach(sale =&gt; {&#10;      sale.items.forEach(item =&gt; {&#10;        const categoryName = item.product.category.name;&#10;        const existing = categoryStats.get(categoryName) || {&#10;          category: categoryName,&#10;          revenue: 0,&#10;          quantity: 0,&#10;        };&#10;&#10;        existing.revenue += Number(item.totalAmount);&#10;        existing.quantity += item.quantity;&#10;        categoryStats.set(categoryName, existing);&#10;      });&#10;    });&#10;&#10;    return Array.from(categoryStats.values())&#10;      .sort((a, b) =&gt; b.revenue - a.revenue);&#10;  }&#10;&#10;  private getPaymentMethodBreakdown(sales: any[]) {&#10;    const paymentStats = {&#10;      CASH: { count: 0, amount: 0 },&#10;      CARD: { count: 0, amount: 0 },&#10;      DIGITAL: { count: 0, amount: 0 },&#10;    };&#10;&#10;    sales.forEach(sale =&gt; {&#10;      paymentStats[sale.paymentMethod].count += 1;&#10;      paymentStats[sale.paymentMethod].amount += Number(sale.totalAmount);&#10;    });&#10;&#10;    return paymentStats;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { Injectable } from '@nestjs/common';&#10;import { PrismaService } from '../prisma/prisma.service';&#10;&#10;@Injectable()&#10;export class AnalyticsService {&#10;  constructor(private prisma: PrismaService) {}&#10;&#10;  async getDashboardOverview() {&#10;    const today = new Date();&#10;    const startOfDay = new Date(today.setHours(0, 0, 0, 0));&#10;    const endOfDay = new Date(today.setHours(23, 59, 59, 999));&#10;    &#10;    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);&#10;    const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59, 999);&#10;&#10;    const [todaySales, monthSales, totalProducts, lowStockProducts, recentSales] = await Promise.all([&#10;      // Today's sales&#10;      this.prisma.sale.aggregate({&#10;        where: {&#10;          createdAt: { gte: startOfDay, lte: endOfDay },&#10;          status: 'COMPLETED',&#10;        },&#10;        _sum: { totalAmount: true },&#10;        _count: true,&#10;      }),&#10;      &#10;      // This month's sales&#10;      this.prisma.sale.aggregate({&#10;        where: {&#10;          createdAt: { gte: startOfMonth, lte: endOfMonth },&#10;          status: 'COMPLETED',&#10;        },&#10;        _sum: { totalAmount: true },&#10;        _count: true,&#10;      }),&#10;      &#10;      // Total products&#10;      this.prisma.product.count({&#10;        where: { isAvailable: true },&#10;      }),&#10;      &#10;      // Low stock products - Fixed query&#10;      this.prisma.product.count({&#10;        where: {&#10;          AND: [&#10;            { lowStockAlert: { not: null } },&#10;            {&#10;              OR: [&#10;                { stock: { lte: 10 } }, // Default low stock threshold&#10;              ]&#10;            }&#10;          ],&#10;        },&#10;      }),&#10;      &#10;      // Recent sales&#10;      this.prisma.sale.findMany({&#10;        take: 10,&#10;        orderBy: { createdAt: 'desc' },&#10;        include: {&#10;          items: {&#10;            include: {&#10;              product: {&#10;                select: { name: true },&#10;              },&#10;            },&#10;          },&#10;        },&#10;      }),&#10;    ]);&#10;&#10;    return {&#10;      todaySales: Number(todaySales._sum.totalAmount || 0),&#10;      todayOrders: todaySales._count,&#10;      monthSales: Number(monthSales._sum.totalAmount || 0),&#10;      monthOrders: monthSales._count,&#10;      totalProducts,&#10;      lowStockProducts,&#10;      recentSales,&#10;    };&#10;  }&#10;&#10;  async getSalesAnalytics(days: number = 30) {&#10;    const endDate = new Date();&#10;    const startDate = new Date();&#10;    startDate.setDate(endDate.getDate() - days);&#10;&#10;    const sales = await this.prisma.sale.findMany({&#10;      where: {&#10;        createdAt: { gte: startDate, lte: endDate },&#10;        status: 'COMPLETED',&#10;      },&#10;      include: {&#10;        items: {&#10;          include: {&#10;            product: {&#10;              include: {&#10;                category: true,&#10;              },&#10;            },&#10;          },&#10;        },&#10;      },&#10;    });&#10;&#10;    const dailySales = this.groupSalesByDate(sales);&#10;    const topProducts = this.getTopSellingProducts(sales);&#10;    const categoryBreakdown = this.getCategoryBreakdown(sales);&#10;    const paymentMethodBreakdown = this.getPaymentMethodBreakdown(sales);&#10;&#10;    return {&#10;      dailySales,&#10;      topProducts,&#10;      categoryBreakdown,&#10;      paymentMethodBreakdown,&#10;      totalRevenue: sales.reduce((sum, sale) =&gt; sum + Number(sale.totalAmount), 0),&#10;      totalOrders: sales.length,&#10;      averageOrderValue: sales.length &gt; 0 ? sales.reduce((sum, sale) =&gt; sum + Number(sale.totalAmount), 0) / sales.length : 0,&#10;    };&#10;  }&#10;&#10;  async getProductPerformance() {&#10;    const products = await this.prisma.product.findMany({&#10;      include: {&#10;        category: true,&#10;        saleItems: {&#10;          include: {&#10;            sale: {&#10;              where: { status: 'COMPLETED' },&#10;            },&#10;          },&#10;        },&#10;      },&#10;    });&#10;&#10;    return products.map(product =&gt; {&#10;      const totalSold = product.saleItems.reduce((sum, item) =&gt; sum + item.quantity, 0);&#10;      const totalRevenue = product.saleItems.reduce((sum, item) =&gt; sum + Number(item.totalAmount), 0);&#10;&#10;      return {&#10;        id: product.id,&#10;        name: product.name,&#10;        category: product.category.name,&#10;        price: Number(product.price),&#10;        stock: product.stock,&#10;        totalSold,&#10;        totalRevenue,&#10;        profitMargin: product.cost ? ((Number(product.price) - Number(product.cost)) / Number(product.price)) * 100 : null,&#10;      };&#10;    }).sort((a, b) =&gt; b.totalRevenue - a.totalRevenue);&#10;  }&#10;&#10;  async getInventoryReport() {&#10;    const products = await this.prisma.product.findMany({&#10;      include: {&#10;        category: true,&#10;      },&#10;    });&#10;&#10;    const totalInventoryValue = products.reduce((sum, product) =&gt; {&#10;      const cost = Number(product.cost || 0);&#10;      return sum + (cost * product.stock);&#10;    }, 0);&#10;&#10;    const lowStockProducts = products.filter(product =&gt;&#10;      product.lowStockAlert &amp;&amp; product.stock &lt;= product.lowStockAlert&#10;    );&#10;&#10;    const outOfStockProducts = products.filter(product =&gt; product.stock === 0);&#10;&#10;    return {&#10;      totalProducts: products.length,&#10;      totalInventoryValue,&#10;      lowStockProducts: lowStockProducts.length,&#10;      outOfStockProducts: outOfStockProducts.length,&#10;      products: products.map(product =&gt; ({&#10;        id: product.id,&#10;        name: product.name,&#10;        category: product.category.name,&#10;        stock: product.stock,&#10;        cost: Number(product.cost || 0),&#10;        inventoryValue: (Number(product.cost || 0)) * product.stock,&#10;        lowStockAlert: product.lowStockAlert,&#10;        isLowStock: product.lowStockAlert ? product.stock &lt;= product.lowStockAlert : false,&#10;      })),&#10;    };&#10;  }&#10;&#10;  private groupSalesByDate(sales: any[]) {&#10;    const dailySales = new Map();&#10;&#10;    sales.forEach(sale =&gt; {&#10;      const date = new Date(sale.createdAt).toISOString().split('T')[0];&#10;      const existing = dailySales.get(date) || { date, sales: 0, orders: 0 };&#10;&#10;      existing.sales += Number(sale.totalAmount);&#10;      existing.orders += 1;&#10;      dailySales.set(date, existing);&#10;    });&#10;&#10;    return Array.from(dailySales.values()).sort((a, b) =&gt; a.date.localeCompare(b.date));&#10;  }&#10;&#10;  private getTopSellingProducts(sales: any[]) {&#10;    const productStats = new Map();&#10;&#10;    sales.forEach(sale =&gt; {&#10;      sale.items.forEach(item =&gt; {&#10;        const productId = item.product.id;&#10;        const existing = productStats.get(productId) || {&#10;          product: item.product,&#10;          quantity: 0,&#10;          revenue: 0,&#10;        };&#10;&#10;        existing.quantity += item.quantity;&#10;        existing.revenue += Number(item.totalAmount);&#10;        productStats.set(productId, existing);&#10;      });&#10;    });&#10;&#10;    return Array.from(productStats.values())&#10;      .sort((a, b) =&gt; b.revenue - a.revenue)&#10;      .slice(0, 10);&#10;  }&#10;&#10;  private getCategoryBreakdown(sales: any[]) {&#10;    const categoryStats = new Map();&#10;&#10;    sales.forEach(sale =&gt; {&#10;      sale.items.forEach(item =&gt; {&#10;        const categoryName = item.product.category.name;&#10;        const existing = categoryStats.get(categoryName) || {&#10;          category: categoryName,&#10;          revenue: 0,&#10;          quantity: 0,&#10;        };&#10;&#10;        existing.revenue += Number(item.totalAmount);&#10;        existing.quantity += item.quantity;&#10;        categoryStats.set(categoryName, existing);&#10;      });&#10;    });&#10;&#10;    return Array.from(categoryStats.values())&#10;      .sort((a, b) =&gt; b.revenue - a.revenue);&#10;  }&#10;&#10;  private getPaymentMethodBreakdown(sales: any[]) {&#10;    const paymentStats = {&#10;      CASH: { count: 0, amount: 0 },&#10;      CARD: { count: 0, amount: 0 },&#10;      DIGITAL: { count: 0, amount: 0 },&#10;    };&#10;&#10;    sales.forEach(sale =&gt; {&#10;      paymentStats[sale.paymentMethod].count += 1;&#10;      paymentStats[sale.paymentMethod].amount += Number(sale.totalAmount);&#10;    });&#10;&#10;    return paymentStats;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/products/products.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/products/products.service.ts" />
              <option name="originalContent" value="import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';&#10;import { PrismaService } from '../prisma/prisma.service';&#10;import { CreateProductDto, UpdateProductDto } from './dto/product.dto';&#10;&#10;@Injectable()&#10;export class ProductsService {&#10;  constructor(private prisma: PrismaService) {}&#10;&#10;  async create(createProductDto: CreateProductDto) {&#10;    // Check if category exists&#10;    const category = await this.prisma.category.findUnique({&#10;      where: { id: createProductDto.categoryId },&#10;    });&#10;&#10;    if (!category) {&#10;      throw new BadRequestException('Category not found');&#10;    }&#10;&#10;    // Check if SKU is unique (if provided)&#10;    if (createProductDto.sku) {&#10;      const existingSku = await this.prisma.product.findUnique({&#10;        where: { sku: createProductDto.sku },&#10;      });&#10;&#10;      if (existingSku) {&#10;        throw new BadRequestException('SKU already exists');&#10;      }&#10;    }&#10;&#10;    return this.prisma.product.create({&#10;      data: createProductDto,&#10;      include: {&#10;        category: true,&#10;      },&#10;    });&#10;  }&#10;&#10;  async findAll(categoryId?: string, isAvailable?: boolean) {&#10;    const where: any = {};&#10;&#10;    if (categoryId) {&#10;      where.categoryId = categoryId;&#10;    }&#10;&#10;    if (typeof isAvailable === 'boolean') {&#10;      where.isAvailable = isAvailable;&#10;    }&#10;&#10;    return this.prisma.product.findMany({&#10;      where,&#10;      include: {&#10;        category: true,&#10;      },&#10;      orderBy: {&#10;        name: 'asc',&#10;      },&#10;    });&#10;  }&#10;&#10;  async findOne(id: string) {&#10;    const product = await this.prisma.product.findUnique({&#10;      where: { id },&#10;      include: {&#10;        category: true,&#10;      },&#10;    });&#10;&#10;    if (!product) {&#10;      throw new NotFoundException(`Product with ID ${id} not found`);&#10;    }&#10;&#10;    return product;&#10;  }&#10;&#10;  async update(id: string, updateProductDto: UpdateProductDto) {&#10;    await this.findOne(id); // Check if exists&#10;&#10;    // Check if new category exists (if provided)&#10;    if (updateProductDto.categoryId) {&#10;      const category = await this.prisma.category.findUnique({&#10;        where: { id: updateProductDto.categoryId },&#10;      });&#10;&#10;      if (!category) {&#10;        throw new BadRequestException('Category not found');&#10;      }&#10;    }&#10;&#10;    // Check if new SKU is unique (if provided)&#10;    if (updateProductDto.sku) {&#10;      const existingSku = await this.prisma.product.findFirst({&#10;        where: {&#10;          sku: updateProductDto.sku,&#10;          NOT: { id },&#10;        },&#10;      });&#10;&#10;      if (existingSku) {&#10;        throw new BadRequestException('SKU already exists');&#10;      }&#10;    }&#10;&#10;    return this.prisma.product.update({&#10;      where: { id },&#10;      data: updateProductDto,&#10;      include: {&#10;        category: true,&#10;      },&#10;    });&#10;  }&#10;&#10;  async remove(id: string) {&#10;    await this.findOne(id); // Check if exists&#10;&#10;    return this.prisma.product.delete({&#10;      where: { id },&#10;    });&#10;  }&#10;&#10;  async updateStock(id: string, quantity: number, operation: 'add' | 'subtract' = 'add') {&#10;    const product = await this.findOne(id);&#10;&#10;    const newStock = operation === 'add'&#10;      ? product.stock + quantity&#10;      : product.stock - quantity;&#10;&#10;    if (newStock &lt; 0) {&#10;      throw new BadRequestException('Insufficient stock');&#10;    }&#10;&#10;    return this.prisma.product.update({&#10;      where: { id },&#10;      data: { stock: newStock },&#10;      include: {&#10;        category: true,&#10;      },&#10;    });&#10;  }&#10;&#10;  async getLowStockProducts() {&#10;    return this.prisma.product.findMany({&#10;      where: {&#10;        AND: [&#10;          { lowStockAlert: { not: null } },&#10;          { stock: { lte: { lowStockAlert: true } } },&#10;        ],&#10;      },&#10;      include: {&#10;        category: true,&#10;      },&#10;      orderBy: {&#10;        stock: 'asc',&#10;      },&#10;    });&#10;  }&#10;&#10;  async getProductsByCategory(categoryId: string) {&#10;    return this.prisma.product.findMany({&#10;      where: {&#10;        categoryId,&#10;        isAvailable: true,&#10;      },&#10;      include: {&#10;        category: true,&#10;      },&#10;      orderBy: {&#10;        name: 'asc',&#10;      },&#10;    });&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';&#10;import { PrismaService } from '../prisma/prisma.service';&#10;import { CreateProductDto, UpdateProductDto } from './dto/product.dto';&#10;&#10;@Injectable()&#10;export class ProductsService {&#10;  constructor(private prisma: PrismaService) {}&#10;&#10;  async create(createProductDto: CreateProductDto) {&#10;    // Check if category exists&#10;    const category = await this.prisma.category.findUnique({&#10;      where: { id: createProductDto.categoryId },&#10;    });&#10;&#10;    if (!category) {&#10;      throw new BadRequestException('Category not found');&#10;    }&#10;&#10;    // Check if SKU is unique (if provided)&#10;    if (createProductDto.sku) {&#10;      const existingSku = await this.prisma.product.findUnique({&#10;        where: { sku: createProductDto.sku },&#10;      });&#10;&#10;      if (existingSku) {&#10;        throw new BadRequestException('SKU already exists');&#10;      }&#10;    }&#10;&#10;    return this.prisma.product.create({&#10;      data: createProductDto,&#10;      include: {&#10;        category: true,&#10;      },&#10;    });&#10;  }&#10;&#10;  async findAll(categoryId?: string, isAvailable?: boolean) {&#10;    const where: any = {};&#10;&#10;    if (categoryId) {&#10;      where.categoryId = categoryId;&#10;    }&#10;&#10;    if (typeof isAvailable === 'boolean') {&#10;      where.isAvailable = isAvailable;&#10;    }&#10;&#10;    return this.prisma.product.findMany({&#10;      where,&#10;      include: {&#10;        category: true,&#10;      },&#10;      orderBy: {&#10;        name: 'asc',&#10;      },&#10;    });&#10;  }&#10;&#10;  async findOne(id: string) {&#10;    const product = await this.prisma.product.findUnique({&#10;      where: { id },&#10;      include: {&#10;        category: true,&#10;      },&#10;    });&#10;&#10;    if (!product) {&#10;      throw new NotFoundException(`Product with ID ${id} not found`);&#10;    }&#10;&#10;    return product;&#10;  }&#10;&#10;  async update(id: string, updateProductDto: UpdateProductDto) {&#10;    await this.findOne(id); // Check if exists&#10;&#10;    // Check if new category exists (if provided)&#10;    if (updateProductDto.categoryId) {&#10;      const category = await this.prisma.category.findUnique({&#10;        where: { id: updateProductDto.categoryId },&#10;      });&#10;&#10;      if (!category) {&#10;        throw new BadRequestException('Category not found');&#10;      }&#10;    }&#10;&#10;    // Check if new SKU is unique (if provided)&#10;    if (updateProductDto.sku) {&#10;      const existingSku = await this.prisma.product.findFirst({&#10;        where: {&#10;          sku: updateProductDto.sku,&#10;          NOT: { id },&#10;        },&#10;      });&#10;&#10;      if (existingSku) {&#10;        throw new BadRequestException('SKU already exists');&#10;      }&#10;    }&#10;&#10;    return this.prisma.product.update({&#10;      where: { id },&#10;      data: updateProductDto,&#10;      include: {&#10;        category: true,&#10;      },&#10;    });&#10;  }&#10;&#10;  async remove(id: string) {&#10;    await this.findOne(id); // Check if exists&#10;&#10;    return this.prisma.product.delete({&#10;      where: { id },&#10;    });&#10;  }&#10;&#10;  async updateStock(id: string, quantity: number, operation: 'add' | 'subtract' = 'add') {&#10;    const product = await this.findOne(id);&#10;&#10;    const newStock = operation === 'add'&#10;      ? product.stock + quantity&#10;      : product.stock - quantity;&#10;&#10;    if (newStock &lt; 0) {&#10;      throw new BadRequestException('Insufficient stock');&#10;    }&#10;&#10;    return this.prisma.product.update({&#10;      where: { id },&#10;      data: { stock: newStock },&#10;      include: {&#10;        category: true,&#10;      },&#10;    });&#10;  }&#10;&#10;  async getLowStockProducts() {&#10;    return this.prisma.product.findMany({&#10;      where: {&#10;        AND: [&#10;          { lowStockAlert: { not: null } },&#10;          { stock: { lte: 10 } }, // Use a fixed threshold for now&#10;        ],&#10;      },&#10;      include: {&#10;        category: true,&#10;      },&#10;      orderBy: {&#10;        stock: 'asc',&#10;      },&#10;    });&#10;  }&#10;&#10;  async getProductsByCategory(categoryId: string) {&#10;    return this.prisma.product.findMany({&#10;      where: {&#10;        categoryId,&#10;        isAvailable: true,&#10;      },&#10;      include: {&#10;        category: true,&#10;      },&#10;      orderBy: {&#10;        name: 'asc',&#10;      },&#10;    });&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/tsconfig.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/tsconfig.json" />
              <option name="originalContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;module&quot;: &quot;commonjs&quot;,&#10;    &quot;declaration&quot;: true,&#10;    &quot;removeComments&quot;: true,&#10;    &quot;emitDecoratorMetadata&quot;: true,&#10;    &quot;experimentalDecorators&quot;: true,&#10;    &quot;allowSyntheticDefaultImports&quot;: true,&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;sourceMap&quot;: true,&#10;    &quot;outDir&quot;: &quot;./dist&quot;,&#10;    &quot;baseUrl&quot;: &quot;./&quot;,&#10;    &quot;incremental&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;strictNullChecks&quot;: false,&#10;    &quot;noImplicitAny&quot;: false,&#10;    &quot;strictBindCallApply&quot;: false,&#10;    &quot;forceConsistentCasingInFileNames&quot;: false,&#10;    &quot;noFallthroughCasesInSwitch&quot;: false,&#10;    &quot;resolveJsonModule&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;types&quot;: [&#10;      &quot;node&quot;&#10;    ],&#10;    &quot;lib&quot;: [&#10;      &quot;ES2020&quot;&#10;    ],&#10;    &quot;moduleResolution&quot;: &quot;node&quot;&#10;  },&#10;  &quot;include&quot;: [&#10;    &quot;src/**/*&quot;,&#10;    &quot;prisma/**/*&quot;&#10;  ],&#10;  &quot;exclude&quot;: [&#10;    &quot;node_modules&quot;,&#10;    &quot;dist&quot;&#10;  ]&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;module&quot;: &quot;commonjs&quot;,&#10;    &quot;declaration&quot;: true,&#10;    &quot;removeComments&quot;: true,&#10;    &quot;emitDecoratorMetadata&quot;: true,&#10;    &quot;experimentalDecorators&quot;: true,&#10;    &quot;allowSyntheticDefaultImports&quot;: true,&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;sourceMap&quot;: true,&#10;    &quot;outDir&quot;: &quot;./dist&quot;,&#10;    &quot;baseUrl&quot;: &quot;./&quot;,&#10;    &quot;incremental&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;strictNullChecks&quot;: false,&#10;    &quot;noImplicitAny&quot;: false,&#10;    &quot;strictBindCallApply&quot;: false,&#10;    &quot;forceConsistentCasingInFileNames&quot;: false,&#10;    &quot;noFallthroughCasesInSwitch&quot;: false,&#10;    &quot;resolveJsonModule&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;lib&quot;: [&#10;      &quot;ES2020&quot;&#10;    ],&#10;    &quot;moduleResolution&quot;: &quot;node&quot;&#10;  },&#10;  &quot;include&quot;: [&#10;    &quot;src/**/*&quot;&#10;  ],&#10;  &quot;exclude&quot;: [&#10;    &quot;node_modules&quot;,&#10;    &quot;dist&quot;,&#10;    &quot;prisma&quot;&#10;  ]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>